# 所有权与作用域

## 作用域

在谈及Rust语言的所有权概念之前，先来回顾类似Java这样的面向对象语言的作用域的概念。像Java这样的纯面向对象语言，有四种作用域，自顶向下为全局作用域（Global Scope），类作用域（Class Scope），函数（方法）作用域（Formal Scope）和本地作用域（Local Scope），本地作用域可以进行内嵌，允许定义内部类和在函数中定义函数的语言中类作用域和函数作用域也可以内嵌。编译器通过符号表和作用域栈来维护代码中某一位置能够访问的变量。

通常一个block的开始和结束意味着一个作用域的开启和关闭，程序中某一点所在的作用域称为**当前作用域**，当前作用域与包含它的程序单元所构成的作用域称为**开作用域**。通常程序中某一点所能访问的变量即为此时开作用域中存在的变量。针对这一点，Rust和大多数语言是相同的，Rust区别于其他语言的特征在于变量可以不随着作用域的关闭而提前消亡，而其他语言中变量的消亡一般是伴随着作用域的关闭而发生。

## 所有权与作用域移动

### 所有权转移与作用域移动的场景

1. 使用变量来对绑定进行初始化
```Rust
{
    ...
    let s1 = String::from("test");
    let s2 = s1; // s1离开当前作用域（开作用域） "test"的所有权由s1转移到s2
    ...
} // 在其他语言中 s1在此处才随着作用域的关闭而离开开作用域
```
在Rust中变量定义指将值绑定在变量上，即变量获取某个值的所有权。当直接使用变量来对一个绑定进行初始化时，实际是将原变量的值与原变量解绑之后重新绑定到新的变量上，即原变量不在具有与其绑定的值，从而在语句处从当前作用域消亡，之后的代码不再能够对其进行访问，换句话说，某个具体的变量值的所有权由原变量转移到了新变量。

2. 函数的参数传递与返回

```Rust
fn handel_string(s: String) -> String {
    let return_value = String::from("return");
    return_value
}

fn main() {
    ...
    let s1 = String::from("s1");
    let s2 = handle_string(s1);  // s1离开当前作用域（开作用域）
//*******************************************************
// 尝试对let s2 = handle_string(s1)这段代码展开
// let s2 = 
// {
//     let s = s1; //此处s即为handle_string的参数变量s 结合场景1理解 s1的值的所有权转移给了s
//     let return_value = String::from("return");
//     return_value // return_value的值发生所有权转移 转移到s2 return_value离开开作用域
// } // s在此处离开开作用域 原s1的值即s的值从此不可访问
//*******************************************************
    ...
}
```
函数的参数传递可以借助C++语言中形参的传递来理解，即在函数开始执行前，发生了参数值的拷贝，直观的说就是编译器在函数体的开头自动加上了参数赋值的语句，这实际上就变成了场景1，再结合场景1就不难理解。

函数返回值其实与通过一个语句块赋值类似，就是使得函数调用语句代表了一个具体的值，可根据需要进行与变量的绑定，即在`let s2 = handel_string(s1);`语句中，`handle_string(s1)`可以理解为与12、3.14、"abc"这样的字面值类似的一个值，该值被绑定到了s2变量上。

3.for循环

```Rust
let a = vec![1, 2, 3, 4];
for _i in a {} // a进入了随'{'而开启的Local Scope，并随'}'作用域的关闭而消亡
// println!("{:?}", a); // error
```

### 基本数据类型

简单的标量数据类型，包括数值型，布尔型，字符型（不包括字符串）以及由他们组成的元组和数组类型，在进程的活动记录中在栈空间上进行维护，其复制开销很小，在上述场景下，编译器会自动进行拷贝创造出新的值绑定到新的变量上，而不发生所有权的转移，这些类型的变量可以采用类似C++，Java中的变量使用方法。但是这些变量的引用与索引也必须遵循引用与索引相关的规则。

### 引用与索引

引用和索引是Rust语言提供的能够在不获得变量值所有权的情况下通过一个新的变量来访问同一个值的手段。要理解这种方式也并不难，这需要结合C/C++语言中的指针。引用和索引之所以能不获得变量值的所有权来访问其他变量，是因为在使用引用和索引时产生了新的值，而通过这个新的值可以对其他变量来进行访问。就如同指针变量一样，指针变量的值实际上是变量在内存空间上的虚拟地址，与变量的值不同，是在定义指针变量时产生的新的值，但是通过这个地址能够对地址处所存储的内容进行访问。

需要特别说明的是，引用和索引可以和基本数据类型一样发生自动拷贝，不发生所有权的移动。
```Rust
let s = "abc"; // the type of literal value "abc" is &str(reference of str)
let _s = s;
println!("{:?}", s); // ok

let slice = &s[0..2];
let _slice = slice;
println!("{:?}", slice); // ok
```

多重引用进行绑定时，Rust编译器可以自动解引用。着也是之前使用&String同样能完成String到&str类型类型转换的原因，严格来将&String的类型是&&str，但是自动解引用使得赋值正常完成。
```Rust
let abc: &&i32 = &&&&&&&&5; // ok
// let bcd: &&&&&&&i32 = &&3; // error 只能发生自动解引用 不能自动引用
// let cde: i32 = abc; // error 自动解引用仅限于引用之间的赋值

```

在Rust语言中变量与值的绑定还存在可变性的约束，因此在使用引用与索引时也要注意可变性的规则。
这些规则总结如下：
- 不能获取不可变变量的可变引用
- 任何时候同一变量在开作用域中只能存在一个可变引用
- 同一变量可以拥有多个不可变引用，但任何时候在开作用域中不能同时存在一个变量的可变引用与不可变引用
- 传递引用类型的参数时可变性需要保持一致
- 如果开作用域中存在变量的引用，则必然存在该变量，即引用的生命周期不能长于变量自身

需要注意的两点：
- 在调用方法时隐式的在方法的作用域内产生了对变量的引用，或可变，或不可变
- 在使用print，assert等宏时也获取了参数变量的引用

### 引用的可变性与绑定的可变性
Rust语言中用mut关键字来声明可变性，而绑定的可变性与引用的可变性是两个不同的概念，需要加以区分。绑定的可变性是指绑定在某个变量上的值是否能改变，而引用的可变性则是指能否通过该引用改变所引用的变量。

```
let mut k = String::from("hello");
let l = &mut k; // l是个不可变的变量，但是绑定了一个可变的引用
l.push_str(" world"); // l不变，l引用的变量k发生了改变
```